---
date created: 2022-06-11 14:38
date updated: 2022-06-11 14:38
---


# 2021前端面试复习

## BFC（块级格式化上下文）

### 作用

- 形成独立空间作用域不影像外部布局

### 触发

- float 不为 none
- position 不为 relative 和 static
- overflow 不为 auto、scroll 和 hidden
- display 值为 table-cell 或 inline-block

tips:触发 BFC 可以解决大部分的脱离文档流、高度塌陷

### 解决高度塌陷

- 给父元素触发 BFC
- 添加固定高度
- 给最后一个标签添加 clear: both 清除浮动属性

## 盒子模型

![[盒子模型.png]]

- box-sizing 属性为 content-box（默认值）时盒子大小等于所有区域的大小的总和
- box-sizing 属性为 border-box 时盒子大小等于属性长宽的大小

## 箭头函数

- 匿名函数语法糖
- 不能用于构造函数
- 没有 prototype 属性
- 不能绑定 this
- 没有 arguments 参数
- 没有 this 指向直接获取最近的作用域中的 this

## 浏览器跨域

### 同源策略网络

| 说明           | 是否允许通讯 |
| ------------ | ------ |
| 同一域名，不同文件或路径 | 允许     |
| 同一域名，不同端口    | 不允许    |
| 同一域名，不同协议    | 不允许    |
| 域名和域名对应 ip   | 不允许    |
| 域相同，子域不同     | 不允许    |
| 不同域名         | 不允许    |

### 解决方法

#### JSONP

- script 标签不受跨域限制

- 前端定义 callback（回调函数）src 接受执行挂有数据的 callback 方法。

- 示例：

  - ```html
    <!-- 前端 -->
    <script>
        window.callback = function (res) {
            console.log(res)
        }
    </script>
    <script src='http://localhost:80/callback.js'></script>
    ```

  - ```javascript
    // 后端
    callback({
        data:'数据'bv/.
    })
    ```

#### 跨域资源共享（CORS）

- W3C 标准，它允许浏览器像跨域的服务器发送 AJAX 请求，兼容浏览器 IE10+

- 需要满足下列条件：

  - 使用下列请求方式之一
    - `GET`
    - `POST`
    - `HEAD`

  - `Content-Type` 的值仅限于下列三者之一：
    - `text/plain`
    - `multipart/form-data`
    - `application/x-www-form-urlencoded`

  - 请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器；`XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。

  - 请求中没有使用 `ReadableStream` 对象。

  - Fetch 规范定义了 [对 CORS 安全的首部字段集合](https://fetch.spec.whatwg.org/[[cors-safelisted-request-header]]) ，不得人为设置该集合之外的其他首部字段。该集合为：
    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `Content-Type` （需要注意额外的限制）
    - `DPR`
    - `Downlink`
    - `Save-Data`
    - `Viewport-Width`
    - `Width`

#### 本地代理(前端工程化工具 `WEBAPCK`|`VITE` 等)

- 使用本地接受后端数据

- 数据转发到本地接口

- node 中间件和 nginx 以及 VPN 翻墙类基本同理

%%TODO：跨域解决方案待完善%%

#### NGINX 代理跨域

#### NODE 中间件代理

#### POSTMESSAGE 跨域

#### WEBSOCKET 协议跨域

#### DOCUMENT.DOMAIN + IFRAME 跨域

#### LOCATION.HASH + IFRAME 跨域

#### WINDOW.NAME + IFRAME 跨域

## 浏览器存储

### COOKIE

- Cookie 是 HTTP 协议中的内容

- 服务器通过 Set-Cookie 头给客户端一串字符串,

- 客户端每次访问相同域名的网页时，必须带上这段字符串

- 服务器读取 Cookie 就知道登录用户的信息（不要存重要信息）

- 客户端要在一段时间内保存这个 Cookie

- Cookie 默认在用户关闭页面后就失效，服务端可以任意设置 Cookie 的过期时间（expires）

- 大小大概在 4kb 以内

- Cookie 遵守同源策略，不过跟 AJAX 的同源策略稍微有些不同，服务端可以对 Cookie 的路径做限制

- Cookie 存在 Windows C 盘的一个文件里

- 一般用来记录不重要的用户信息，或者存储 SessionID，用于跟踪用户

- Cookie 内容太多会影响请求性能，因此尽可能少在 Cookie 中存储信息

- Cookie 的问题：**用户可以随意篡改 Cookie**

- 前端尽量不要操作 Cookie

#### SESSION

- Session 依赖于 Cookie

- 将 SessionID（随机数）通过 Cookie 发给客户端

- 客户端访问服务器时，服务器读取 SessionID

- 服务器有一块内存（哈希表）保存了所有 session

- 通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email

- 这块内存（哈希表）就是服务器上的所有 session

### LOCALSTORAGE（本地存储）

- LocalStorage 跟 HTTP 无关

- 只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格）

- 每个域名 localStorage 最大存储量为 2MB - 10MB 左右（各个浏览器不一样）

- 常用场景：记录有没有提示过用户（没有用的信息，不能记录密码）

- LocalStorage 永久有效，除非用户清理缓存

### SESSIONSTORGE（会话存储）

- 基本和 LocalStorage 一样，区别就是保存时间不同
- SessionStorage 在用户关闭页面（会话结束）后就失效

### INDEXEDDB

- IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据。通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被 JavaScript 创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。
- 特性：
  - 键值对储存
  - 异步
  - 支持事务
  - 同源限制
  - 储存空间大
  - 支持二进制储存

### SQLITE

- SQLite 是一款轻型的针对本地化存储的数据库(native database)，它是一种关系型数据库管理系统。
- 底层由 C 语言函数库组成，以嵌入式作为设计目标，在占用资源非常少的情况下实现强大的数据库级的数据存储，整个数据库引擎大小大致只有 4M 多。
- 支持现今所有主流开发语言，如 C、C++、PHP、Java、C#、Python 等
- 实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。SQLite 源代码不受版权限制。
- 特性:
  - 数据集中控制
  - 数据独立性高
  - 数据库引擎小
  - 数据冗余度小
  - 数据架构化

### WEB SQL（已弃用）

## VUE生命周期

### 简介

- Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。

![[Vue生命周期.png]]

### BEFORECREATE（创建前）

- 在实例初始化之后，进行数据侦听和时间/侦听器的配置之前同步调用
- 这个时候，数据还没有挂载呢，只是一个空壳
- 此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。

### CREATED（创建后）

- 在实例创建完成后被立即同步调用。
- 以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 `$el` property 目前尚不可用
- 这里更改数据不会触发`updated`函数
- 渲染前倒数第二次更改数据的机会，不会触发其他钩子函数，一般可以在这里做初始化数据

### BEFOREMOUNT(挂载前)

- 在挂载开始之前被调用：相关的 `render` 函数首次被调用
- 虚拟dom已经创建完成，这里也可以更改数据，不会触发`updated`
- 渲染前最后一次更改数据的机会，不会触发其他钩子，一般可以在这里做初始化数据
- 实例已完成以下配置：编译模板，把data里面的数据和模板生成html，完成el和data初始化

### MOUNTED（挂载完成）

- 实例被挂载后调用

- 组件已经出现在页面中，数据、真是dom已处理好，事件都已经挂载好了，可以在这里操作真是dom等事情

- 模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作

- 这时 `el` 被新创建的 `vm.$el` 替换了。如果根实例挂载到了一个文档内的元素上，当 `mounted` 被调用时 `vm.$el` 也在文档内

- 注意 `mounted` **不会**保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 `mounted` 内部使用 vm.$nextTick

### BEFOREUPDATE（更新前）

- 在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。
- 该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行
- 这里不能更改数据，否则会陷入死循环

### UPDATED（更新后）

- 这里不能更改数据，否则会陷入死循环
- 数据已完成更改，dom也重新render完成
- 可以执行依赖于 DOM 的操作
- 应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之
- 注意，`updated` **不会**保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 `updated` 里使用 vm.$nextTick

### BEFOREDESTROY（销毁前）

- 在实例销毁前调用，实例任然完全可用

### DESTROYED（销毁后）

- 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。

### ERRORCAPTURED（捕获后代组件错误）

- 在子组件发生错误时调用

### ACTIVATED（被 KEEP-ALIVE 缓存的组件激活时调用）

### DEACTIVATED（被 KEEP-ALIVE 缓存的组件失活时调用）

## 数据类型

### 值类型(基本类型)：

- 字符串（String）
- 数字(Number)
- 布尔(Boolean)
- 空（Null）
- 未定义（Undefined）
- 唯一值（Symbol）

### 引用数据类型：

- 对象(Object)
- 数组(Array)
- 函数(Function)
