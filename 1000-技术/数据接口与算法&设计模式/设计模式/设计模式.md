---
title: 设计模式
aliases:
tags:
date created: 2022-11-29 14:29:22
date updated: 2022-11-29 22:01:17
---

# 设计模式

## 什么是设计模式

- 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
- 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
- 设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
- 设计模式不是某一种特定的编程语言实现的，而是一套思想和原则

## 设计模式六大原则(SOLID)

- 单一职责原则(Single Responsibility Principle)
- 开闭原则(Open Close Principle)
- 里氏替换原则(Liskov Substitution Principle)
- 迪米特(最少知道)法则(Law of Demeter)
- 接口隔离原则(Interface Segregation Principle)
- 依赖倒转原则(Dependence Inversion Principle)

### 单一职责原则(Single Responsibility Principle)

- 定义：一个类只负责一项职责
- 优点：降低类的复杂度、提高类的可读性、提高系统的可维护性、变更引起的风险降低
- 缺点：增加类的个数、增加系统的复杂度
- 适用场景：只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 开闭原则(Open Close Principle)

- 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
- 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 里氏替换原则(Liskov Substitution Principle)

- 定义：所有引用基类的地方必须能透明地使用其子类的对象
- 优点：可以在运行时判断任意一个实例对象是否是某个类的实例
- 缺点：增加了代码的复杂度
- 适用场景：只有当子类可以替换掉所有父类的出现的地方，父类才能真正被复用，而且子类还能增加父类的新功能

### 迪米特法则(Law of Demeter)

- 定义：一个对象应该对其他对象保持最少的了解
- 优点：降低类之间的耦合度，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 接口隔离原则(Interface Segregation Principle)

- 定义：使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口
- 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 依赖倒转原则(Dependence Inversion Principle)

- 定义：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
- 优点：可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程



## GOF的23种设计模式

### 创建型模式(5种)

#### 工厂方法模式(Factory Method)

  - 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
  - 优点：用户只需要关心所需产品对应的工厂，无需关心创建细节，加入新产品符合开闭原则，提高了系统的可扩展性
  - 缺点：类的个数容易过多，增加了系统的复杂度
  - 适用场景：日志记录，数据库访问，文件访问，缓存访问，消息队列访问等
  - 代码示例：[[工厂方法模式(Factory Method)]]

#### 抽象工厂模式(Abstract Factory)

  - 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
  - 优点：用户只需要关心所需产品对应的工厂，无需关心创建细节，加入新产品符合开闭原则，提高了系统的可扩展性
  - 缺点：类的个数容易过多，增加了系统的复杂度
  - 适用场景：日志记录，数据库访问，文件访问，缓存访问，消息队列访问等
  - 代码示例：[[抽象工厂模式(Abstract Factory)]]

#### 生成器模式(Builder)

  - 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
  - 优点：用户只需要指定需要建造的类型就可以得到它们，建造过程和细节不需要知道，加入新产品符合开闭原则，提高了系统的可扩展性
  - 缺点：增加了系统的复杂度
  - 适用场景：需要生成的对象具有复杂的内部结构，这些对象内部属性本身相互依赖
  - 代码示例：[[生成器模式(Builder)]]

#### 原型模式(Prototype)

  - 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
  - 优点：性能优良，逃避构造函数的约束
  - 缺点：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造的时候，需要修改代码，违背了开闭原则
  - 适用场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等
  - 代码示例：[[原型模式(Prototype)]]

#### 单例模式(Singleton)

  - 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点
  - 优点：在内存里只有一个实例，减少了内存开销，避免对资源的多重占用
  - 缺点：没有接口，扩展困难
  - 适用场景：要求生产唯一序列号的环境
  - 代码示例：[[单例模式(Singleton)]]

## 结构型模式

  - 结构型模式描述如何将类或对象按某种布局组成更大的结构
  - 结构型模式分为类结构型模式和对象结构型模式
  - 类结构型模式使用继承机制来组织接口和类
  - 对象结构型模式则使用组合或聚合来组合对象


## 相关资料
  - [免费在线学习代码重构和设计模式](https://refactoringguru.cn/)
