---
title: 设计模式
aliases:
tags:
date created: 2022-11-29 14:29:22
date updated: 2022-11-29 16:12:23
---

# 设计模式

## 什么是设计模式

1. 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
2. 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
3. 设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
4. 设计模式不是某一种特定的编程语言实现的，而是一套思想和原则

## 设计模式六大原则

1. 单一职责原则
2. 里氏替换原则
3. 依赖倒转原则
4. 接口隔离原则
5. 迪米特法则
6. 开闭原则

### 单一职责原则

1. 定义：一个类只负责一项职责
2. 优点：降低类的复杂度、提高类的可读性、提高系统的可维护性、变更引起的风险降低
3. 缺点：增加类的个数、增加系统的复杂度
4. 适用场景：只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 里氏替换原则

1. 定义：所有引用基类的地方必须能透明地使用其子类的对象
2. 优点：可以在运行时判断任意一个实例对象是否是某个类的实例
3. 缺点：增加了代码的复杂度
4. 适用场景：只有当子类可以替换掉所有父类的出现的地方，父类才能真正被复用，而且子类还能增加父类的新功能

### 依赖倒转原则

1. 定义：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
2. 优点：可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
3. 缺点：增加了系统的复杂度和理解难度
4. 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 接口隔离原则

1. 定义：使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口
2. 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
3. 缺点：增加了系统的复杂度和理解难度
4. 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 迪米特法则

1. 定义：一个对象应该对其他对象保持最少的了解
2. 优点：降低类之间的耦合度，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
3. 缺点：增加了系统的复杂度和理解难度
4. 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 开闭原则

1. 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
2. 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
3. 缺点：增加了系统的复杂度和理解难度
4. 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

## 设计模式和类型

### 创建型模式

1. 单例模式(Singleton)
  - 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点
  - 优点：在内存中只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问
  - 缺点：没有接口，扩展困难
  - 适用场景：要求生产唯一序列号的环境；在整个项目中需要一个共享访问点或共享数据；创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源
  - 代码示例：[单例模式]
2. 工厂模式(Factory)
  - 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
  - 优点：用户只需要关心所需产品对应的工厂，无需关心创建细节；加入新产品符合开闭原则，提高了系统的可扩展性
  - 缺点：类的个数容易过多，增加复杂度；增加了系统的抽象性和理解难度
  - 适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节；一个类通过其子类来指定创建哪个对象
  - 代码示例：[工厂模式]
3. 抽象工厂模式(Abstract Factory)
  - 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
  - 优点：隔离了具体类的生成，使得客户端不需要知道什么被创建；将一个系列的产品族统一到一起创建
  - 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
  - 适用场景：系统中有多于一个的产品族，而系统只消费其中某一族的产品
  - 代码示例：[抽象工厂模式]
4. 建造者模式(Builder)
  - 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
  - 优点：封装性好，构建和表示分离；扩展性好，各个具体的建造者相互独立，有利于系统的解耦；客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险
  - 缺点：产生多余的Builder对象以及Director对象；产品内部发生变化，建造者都要修改，成本较大
  - 适用场景：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品
  - 代码示例：[建造者模式]
5. 原型模式(Prototype)
  - 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
  - 优点：性能优良；逃避构造函数的约束
  - 缺点：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改代码，违背了开闭原则；深拷贝、浅拷贝要运用得当
  - 适用场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；一个对象多个修改者的场景，例如：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝
  - 代码示例：[原型模式]

### 结构型模式

1. 适配器模式(Adapter)
  - 定义：将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
  - 优点：可以让任何两个没有关联的类一起运行；提高了类的复用；增加了类的透明度；灵活性好
  - 缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握；由于JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类
  - 适用场景：系统需要使用现有的类，而此类的接口不符合系统的需要；想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；（对象适配器）需要适配的是一个类，但是适配者类不是抽象类
  - 代码示例：[适配器模式]
2. 桥接模式(Bridge)
  - 定义：将抽象部分与它的实现部分分离，使它们都可以独立的变化
  - 优点：分离抽象接口及其实现部分；提高了系统的可扩展性；符合开闭原则
  - 缺点：增加了系统的理解与设计难度；增加了系统的代码量
  - 适用场景：不希望或不适用使用继承的场景；接口或抽象类不稳定的场景；重用性要求较高的场景
  - 代码示例：[桥接模式]
3. 装饰器模式(Decorator)
  - 定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类实现更为灵活
  - 优点：装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态的给一个对象扩展功能，即插即用；通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；符合开闭原则
  - 缺点：会出现更多的代码，更多的类，增加程序复杂性
  - 适用场景：扩展一个类的功能或给一个类添加附加职责；动态的给一个对象添加功能，这些功能可以再动态的撤销；增加一些列功能，而且这些功能还可以再动态的撤销
  - 代码示例：[装饰器模式]
4. 组合模式(Composite)
  - 定义：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性
  - 优点：高层模块调用简单；节点自由增加
  - 缺点：限制类型时会较为复杂
  - 适用场景：希望客户端可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象；需要表示对象的部分-整体层次结构；希望客户端可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象
  - 代码示例：[组合模式]
5. 外观模式(Facade)
  - 定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
  - 优点：减少系统相互依赖；提高灵活性；提高了安全性
  - 缺点：不符合开闭原则
  - 适用场景：为复杂的模块或子系统提供外界访问的模块；子系统相对独立；预防低水平人员带来的风险
  - 代码示例：[外观模式]
6. 享元模式(Flyweight)
  - 定义：运用共享技术有效地支持大量细粒度的对象
  - 优点：大大减少对象的创建，降低系统的内存，使效率提高
  - 缺点：关注内/外部状态，关注线程安全问题，使程序的逻辑复杂化
  - 适用场景：系统中有大量对象；这些对象消耗大量内存；这些对象的状态大部分可以外部化；这些对象可以按照内部状态分成较小的组；系统不依赖于这些对象身份，这些对象是不可分辨的
  - 代码示例：[享元模式]
7. 代理模式(Proxy)
  - 定义：为其他对象提供一种代理以控制对这个对象的访问
  - 优点：职责清晰；高扩展性；智能化
  - 缺点：增加了系统的复杂度
  - 适用场景：远程代理；虚拟代理；Copy-on-Write 代理；保护代理；Cache 代理；防火墙代理；同步代理；智能引用代理
  - 代码示例：[代理模式]
8. 委托模式(Delegate)
  - 定义：对象A委托给对象B来做某件事情
  - 优点：降低类之间的耦合度，符合迪米特法则；增加程序的可扩展性
  - 缺点：增加系统的复杂度
  - 适用场景：需要对一个对象的功能进行扩展，但是又不能采用继承的方式
  - 代码示例：[委托模式]

### 行为型模式

1. 模板方法模式(Template Method)
2. 命令模式(Command)
3. 迭代器模式(Iterator)
4. 观察者模式(Observer)
5. 中介者模式(Mediator)
6. 备忘录模式(Memento)
7. 状态模式(State)
8. 策略模式(Strategy)
9. 职责链模式(Chain of Responsibility)
10. 解释器模式(Interpreter)
11. 访问者模式(Visitor)
12. 发布订阅模式(Publish/Subscribe)

### 其他模式

1. MVC模式
2. MVVM模式
