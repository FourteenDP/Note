---
title: 设计模式
aliases:
tags:
date created: 2022-11-29 14:29:22
date updated: 2022-11-30 16:50:45
---

# 设计模式

## 什么是设计模式

- 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
- 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
- 设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
- 设计模式不是某一种特定的编程语言实现的，而是一套思想和原则

## 设计模式六大原则(SOLID)

- 单一职责原则(Single Responsibility Principle)
- 开闭原则(Open Close Principle)
- 里氏替换原则(Liskov Substitution Principle)
- 迪米特(最少知道)法则(Law of Demeter)
- 接口隔离原则(Interface Segregation Principle)
- 依赖倒转原则(Dependence Inversion Principle)

### 单一职责原则(Single Responsibility Principle)

- 定义：一个类只负责一项职责
- 优点：降低类的复杂度、提高类的可读性、提高系统的可维护性、变更引起的风险降低
- 缺点：增加类的个数、增加系统的复杂度
- 适用场景：只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 开闭原则(Open Close Principle)

- 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
- 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 里氏替换原则(Liskov Substitution Principle)

- 定义：所有引用基类的地方必须能透明地使用其子类的对象
- 优点：可以在运行时判断任意一个实例对象是否是某个类的实例
- 缺点：增加了代码的复杂度
- 适用场景：只有当子类可以替换掉所有父类的出现的地方，父类才能真正被复用，而且子类还能增加父类的新功能

### 迪米特法则(Law Of Demeter)

- 定义：一个对象应该对其他对象保持最少的了解
- 优点：降低类之间的耦合度，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 接口隔离原则(Interface Segregation Principle)

- 定义：使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口
- 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 依赖倒转原则(Dependence Inversion Principle)

- 定义：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
- 优点：可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

## GOF的23种设计模式

- GOF的23种设计模式是由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在1994年发表的一本名为《设计模式：可复用面向对象软件的基础》的书中提出的
- GOF的23种设计模式是基于面向对象的，所以在学习设计模式之前，先要学习面向对象的基本概念
- GOF的23种设计模式是基于SOLID原则的，所以在学习设计模式之前，先要学习SOLID原则

### 创建型模式(5种)

- 创建型模式是对类的实例化过程进行抽象，能够将软件模块中对象的创建和对象的使用分离
- 创建型模式的主要特点是“将对象的创建与使用分离”
- 创建型模式的主要优点是降低系统的耦合度，一个类的实例化可以延迟到其使用时
- 创建型模式的主要缺点是需要额外的工作，有时候会增加系统的复杂度
- 创建型模式的主要应用场景是：系统要独立于它的产品的创建、构成和表示时；一个类要通过其子类来指定创建哪个对象时；一个类要通过其子类来指定创建哪个对象时；一个类的实例对象只能有几个不同状态组合中的一种时；系统要求提供一个类的库，所有的类都要符合一定的接口时；系统要求提供一个类的库，所有的类都要符合一定的接口时
- 创建型模式包括：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

#### 工厂方法模式(Factory Method)

- 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
- 优点：用户只需要关心所需产品对应的工厂，无需关心创建细节；加入新产品符合开闭原则，提高了系统的可扩展性
- 缺点：类的个数容易过多，增加复杂度；增加了系统的抽象性和理解难度
- 适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节；一个类通过其子类来指定创建哪个对象
#### 抽象工厂模式(Abstract Factory)

- 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
- 优点：隔离了具体类的生成，使得客户端不需要知道什么被创建；将一个系列的产品族统一到一起创建；增加新的产品族很方便，无须修改已有系统，符合开闭原则
- 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
- 适用场景：系统中有多于一个的产品族，而系统只消费其中某一产品族；系统要求提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现

#### 单例模式(Singleton)

- 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 优点：在内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问
- 缺点：没有接口，扩展困难；与单一职责原则冲突
- 适用场景：要求生产唯一序列号；在整个项目中需要一个共享访问点或共享数据；创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源

#### 建造者模式(Builder)

- 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
- 优点：封装性好，构建和表示分离；扩展性好，各个具体的建造者相互独立，有利于系统的解耦；客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险
- 缺点：产生多余的Builder对象以及Director对象；产品内部发生变化，建造者都要修改，成本较大
- 适用场景：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品

#### 原型模式(Prototype)

- 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
- 优点：性能提高；逃避构造函数的约束
- 缺点：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有类进行改造时，需要修改代码，违背了开闭原则；当实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦；深克隆、浅克隆要运用得当
- 适用场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；一个对象多个修改者的场景，例如，一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝

### 结构型模式(7种)

- 结构型模式是对类或对象如何组合成较大的结构进行描述，能够使结构更加灵活，更加易于使用
- 结构型模式的主要特点是“关注类或对象的组合”
- 结构型模式的主要优点是可以提高类的透明性和复用性，可以提高系统的整体性能
- 结构型模式的主要缺点是使用结构型模式需要产生很多额外的类，增加系统的复杂度
- 结构型模式的主要应用场景是：需要增加由于继承而产生的复杂性时；需要对客户隐藏一个类的具体实现时；需要提高类的复用性时；需要对类进行分层次进行设计时
- 结构型模式包括：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式

#### 适配器模式(Adapter)

- 定义：将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
- 优点：可以让任何两个没有关联的类一起运行；提高了类的复用；增加了类的透明度；灵活性好
- 缺点：过多使用适配器，会让系统非常零乱，不易整体进行把握；由于JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类
- 适用场景：系统需要使用现有的类，而此类的接口不符合系统的需要；想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；（对象适配器）需要适配的是一个类，但是适配者类不是抽象类，而是一个具体类，而且不可能改变它的代码

### 行为型模式(11种)

- 行为型模式是对在不同的对象之间划分责任和算法的抽象化，能够有效地分配职责和算法
- 行为型模式的主要特点是“关注对象之间的通信”
- 行为型模式的主要优点是可以减少系统中各类之间的耦合度，提高系统的灵活性，可以让系统更加易于维护和扩展
- 行为型模式的主要缺点是使用行为型模式会增加系统的复杂度
- 行为型模式的主要应用场景是：系统需要在不同的时间指定不同的行为时；多个类只有在算法或行为上稍有不同的场景时；系统需要动态地在几种算法中选择一种时；一个对象的行为依赖于它的状态，而且它必须在运行时刻根据状态改变它的行为时
- 行为型模式包括：模板方法模式、策略模式、命令模式、责任链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式、解释器模式

## 其他模式

- 其他模式是对软件开发中一些特殊情况的解决方案,它们并不属于GOF23种设计模式,但是也是非常重要的,也是我们在软件开发中经常使用的




## 相关资料

- [免费在线学习代码重构和设计模式](https://refactoringguru.cn/)
