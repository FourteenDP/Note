---
title: 设计模式
aliases:
tags:
date created: 2022-11-29 14:29:22
date updated: 2022-11-29 22:01:17
---

# 设计模式

## 什么是设计模式

- 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
- 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
- 设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
- 设计模式不是某一种特定的编程语言实现的，而是一套思想和原则

## 设计模式六大原则

- 单一职责原则
- 里氏替换原则
- 依赖倒转原则
- 接口隔离原则
- 迪米特法则
- 开闭原则

### 单一职责原则

- 定义：一个类只负责一项职责
- 优点：降低类的复杂度、提高类的可读性、提高系统的可维护性、变更引起的风险降低
- 缺点：增加类的个数、增加系统的复杂度
- 适用场景：只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 里氏替换原则

- 定义：所有引用基类的地方必须能透明地使用其子类的对象
- 优点：可以在运行时判断任意一个实例对象是否是某个类的实例
- 缺点：增加了代码的复杂度
- 适用场景：只有当子类可以替换掉所有父类的出现的地方，父类才能真正被复用，而且子类还能增加父类的新功能

### 依赖倒转原则

- 定义：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
- 优点：可以减少类间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 接口隔离原则

- 定义：使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口
- 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 迪米特法则

- 定义：一个对象应该对其他对象保持最少的了解
- 优点：降低类之间的耦合度，提高系统的稳定性，提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

### 开闭原则

- 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
- 优点：可以提高代码的可读性和可维护性，降低变更引起的风险
- 缺点：增加了系统的复杂度和理解难度
- 适用场景：在系统中尽量使用面向接口编程，而不是面向实现编程

## 设计模式和类型

### 创建型模式

#### 单例模式(Singleton)

  - 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点
  - 优点：在内存中只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问
  - 缺点：没有接口，扩展困难
  - 适用场景：要求生产唯一序列号的环境；在整个项目中需要一个共享访问点或共享数据；创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源
  - 代码示例：[[Singleton.cs|单例模式]]

#### 工厂模式(Factory)

  - 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
  - 优点：用户只需要关心所需产品对应的工厂，无需关心创建细节；加入新产品符合开闭原则，提高了系统的可扩展性
  - 缺点：类的个数容易过多，增加复杂度；增加了系统的抽象性和理解难度
  - 适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节；一个类通过其子类来指定创建哪个对象
  - 代码示例：[[Factory.cs|工厂模式]]

#### 抽象工厂模式(Abstract Factory)

  - 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
  - 优点：隔离了具体类的生成，使得客户端不需要知道什么被创建；将一个系列的产品族统一到一起创建
  - 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
  - 适用场景：系统中有多于一个的产品族，而系统只消费其中某一族的产品
  - 代码示例：[[AbstractFactory.cs|抽象工厂模式]]

#### 建造者模式(Builder)

  - 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
  - 优点：封装性好，构建和表示分离；扩展性好，各个具体的建造者相互独立，有利于系统的解耦；客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险
  - 缺点：产生多余的Builder对象以及Director对象；产品内部发生变化，建造者都要修改，成本较大
  - 适用场景：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品
  - 代码示例：[[Builder.cs|建造者模式]]

#### 原型模式(Prototype)

  - 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
  - 优点：性能优良；逃避构造函数的约束
  - 缺点：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改代码，违背了开闭原则；深拷贝、浅拷贝要运用得当
  - 适用场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；一个对象多个修改者的场景，例如：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝
  - 代码示例：[[Prototype.cs|原型模式]]

### 结构型模式

#### 适配器模式(Adapter)

  - 定义：将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
  - 优点：可以让任何两个没有关联的类一起运行；提高了类的复用；增加了类的透明度；灵活性好
  - 缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握；由于JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类
  - 适用场景：系统需要使用现有的类，而此类的接口不符合系统的需要；想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；（对象适配器）需要适配的是一个类，但是适配者类不是抽象类
  - 代码示例：[[Adapter.cs|适配器模式]]

#### 桥接模式(Bridge)

  - 定义：将抽象部分与它的实现部分分离，使它们都可以独立的变化
  - 优点：分离抽象接口及其实现部分；提高了系统的可扩展性；符合开闭原则
  - 缺点：增加了系统的理解与设计难度；增加了系统的代码量
  - 适用场景：不希望或不适用使用继承的场景；接口或抽象类不稳定的场景；重用性要求较高的场景
  - 代码示例：[[Bridge.cs|桥接模式]]

#### 装饰器模式(Decorator)

  - 定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类实现更为灵活
  - 优点：装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态的给一个对象扩展功能，即插即用；通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果；符合开闭原则
  - 缺点：会出现更多的代码，更多的类，增加程序复杂性
  - 适用场景：扩展一个类的功能或给一个类添加附加职责；动态的给一个对象添加功能，这些功能可以再动态的撤销；增加一些列功能，而且这些功能还可以再动态的撤销
  - 代码示例：[[Decorator.cs|装饰器模式]]

#### 组合模式(Composite)

  - 定义：将对象组合成树形结构以表示“部分 -整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性
  - 优点：高层模块调用简单；节点自由增加
  - 缺点：限制类型时会较为复杂
  - 适用场景：希望客户端可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象；需要表示对象的部分 -整体层次结构；希望客户端可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象
  - 代码示例：[[Composite.cs|组合模式]]

#### 外观模式(Facade)

  - 定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
  - 优点：减少系统相互依赖；提高灵活性；提高了安全性
  - 缺点：不符合开闭原则
  - 适用场景：为复杂的模块或子系统提供外界访问的模块；子系统相对独立；预防低水平人员带来的风险
  - 代码示例：[[Facade.cs|外观模式]]

#### 享元模式(Flyweight)

  - 定义：运用共享技术有效地支持大量细粒度的对象
  - 优点：大大减少对象的创建，降低系统的内存，使效率提高
  - 缺点：关注内/外部状态，关注线程安全问题，使程序的逻辑复杂化
  - 适用场景：系统中有大量对象；这些对象消耗大量内存；这些对象的状态大部分可以外部化；这些对象可以按照内部状态分成较小的组；系统不依赖于这些对象身份，这些对象是不可分辨的
  - 代码示例：[[Flyweight.cs|享元模式]]

#### 代理模式(Proxy)

  - 定义：为其他对象提供一种代理以控制对这个对象的访问
  - 优点：职责清晰；高扩展性；智能化
  - 缺点：增加了系统的复杂度
  - 适用场景：远程代理；虚拟代理；Copy-on-Write 代理；保护代理；Cache 代理；防火墙代理；同步代理；智能引用代理
  - 代码示例：[[Proxy.cs|代理模式]]

### 行为型模式

#### 模板方法模式(Template Method)

  - 定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
  - 优点：封装不变部分，扩展可变部分；提取公共代码，便于维护；行为由父类控制，子类实现
  - 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大
  - 适用场景：有多个子类共有的方法，且逻辑相同；重要的、复杂的方法，可以考虑作为模板方法
  - 代码示例：[[TemplateMethod.cs|模板方法模式]]

#### 命令模式(Command)

  - 定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
  - 优点：降低系统耦合度；容易扩展新的命令和命令的排队；方便实现对请求的Undo和Redo
  - 缺点：使用命令模式可能会导致某些系统有过多的具体命令类
  - 适用场景：认为是命令的地方都可以使用命令模式，如：GUI按钮、宏命令、模拟DOS命令
  - 代码示例：[[Command.cs|命令模式]]

#### 迭代器模式(Iterator)

  - 定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示
  - 优点：分离了集合对象的遍历行为；支持以不同的方式遍历一个聚合对象；简化了聚合类
  - 缺点：类的个数成对增加；增加了系统的复杂度；违背了“迪米特法则”
  - 适用场景：访问一个聚合对象的内容而无须暴露它的内部表示；为遍历不同的聚合结构提供一个统一的接口（即，支持多态迭代）
  - 代码示例：[[Iterator.cs|迭代器模式]]

#### 观察者模式(Observer)

  - 定义：定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新
  - 优点：观察者和被观察者之间是抽象耦合；建立一套触发机制
  - 缺点：如果一个被观察者有很多直接和间接的观察者时，将所有的观察者都通知到会花费很多时间
  - 适用场景：关联行为场景；事件多级触发场景；跨系统的消息交换场景，如消息队列、事件总线的处理机制
  - 代码示例：[[Observer.cs|观察者模式]]

#### 中介者模式(Mediator)

  - 定义：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
  - 优点：降低了类的复杂度，将一对多转化成了一对一；各个类之间的解耦；符合迪米特法则
  - 缺点：中介者会庞大，变得复杂难以维护
  - 适用场景：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类
  - 代码示例：[[Mediator.cs|中介者模式]]

#### 备忘录模式(Memento)

  - 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态
  - 优点：为用户提供一种可恢复机制；存档信息的封装；实现了信息的封装，一个备忘录可以存储另一个备忘录
  - 缺点：资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免地要占用大量的存储空间
  - 适用场景：保存及恢复数据相关业务场景；后悔药场景
  - 代码示例：[[Memento.cs|备忘录模式]]

#### 状态模式(State)

  - 定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来好像修改了它的类
  - 优点：封装了转换规则；枚举可能的状态，在枚举状态之前需要确定状态种类；将所有与某个状态有关的行为都放入一个对象中，所有状态对应的行为都是集中在一个对象中，通过定义新的子类可以很容易地增加新的状态和转换
  - 缺点：状态模式的使用必然会增加系统类和对象的个数；状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱
  - 适用场景：行为随状态改变而改变的场景；条件、分支语句的代替者
  - 代码示例：[[State.cs|状态模式]]

#### 策略模式(Strategy)

  - 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化
  - 优点：算法可以自由切换；避免使用多重条件判断；扩展性良好
  - 缺点：策略类会增多；所有策略类都需要对外暴露
  - 适用场景：系统有很多类，而区分它们的只是他们直接的行为；一个系统需要动态地在几种算法中选择一种
  - 代码示例：[[Strategy.cs|策略模式]]

#### 职责链模式(Chain Of Responsibility)

  - 定义：为请求创建了一个接收者对象的链
  - 优点：降低耦合度；简化了对象；增强了给对象指派职责的灵活性；增加新的请求处理类很方便
  - 缺点：不能保证请求一定被接收；对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响；职责链建议只有在处理的对象比较多时才使用
  - 适用场景：有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求
  - 代码示例：[[ChainOfResponsibility.cs|职责链模式]]

#### 解释器模式(Interpreter)

  - 定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子
  - 优点：扩展性好；灵活；易于实现简单文法
  - 缺点：可利用场景少；对于复杂的文法比较难维护；解释器模式会引起类膨胀；解释器模式采用递归调用方法
  - 适用场景：可以将一个需要解释执行的语言中的句子表示为一个抽象语法树；一些重复出现的问题可以用一种简单的语言来进行表达；一个简单语法需要解释的场景
  - 代码示例：[[Interpreter.cs|解释器模式]]

#### 访问者模式(Visitor)

  - 定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作
  - 优点：符合单一职责原则；优秀的扩展性；灵活性
  - 缺点：具体元素对访问者公布细节；具体元素变更比较困难；违背了依赖倒置原则；违背了迪米特法则
  - 适用场景：对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作；需要对一个对象结构中的对象进行很多不同且不相关的操作，而需要避免让这些操作“污染”这些对象的类；对象结构中的对象需要提供多种不同且不相关的操作，而且需要避免让这些操作“污染”这些对象的类；不希望访问者的变更影响到对象的结构
  - 代码示例：[[Visitor.cs|访问者模式]]

#### 发布订阅模式(Publish/Subscribe)

  - 定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新
  - 优点：符合开闭原则；符合单一职责原则；符合迪米特法则
  - 缺点：可能带来性能问题；可能存在内存泄漏
  - 适用场景：一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变；一个对象必须通知其他对象，而它又不能假定其他对象是谁；需要在不同时间指定不同的对象接收通知；一个对象不能直接引用另一个对象
  - 代码示例：[[PublishSubscribe.cs|发布订阅模式]]

#### 委托模式(Delegate)

  - 定义：对象A将自己的一些行为委托给对象B，对象B对对象A的行为进行了封装
  - 优点：符合单一职责原则；符合开闭原则；符合迪米特法则
  - 缺点：可能带来性能问题；可能存在内存泄漏
  - 适用场景：需要对一个对象的行为进行封装，以便在不同的场景中使用不同的行为；需要对一个对象的行为进行动态的添加、删除和修改；一个对象的行为取决于另一个对象的状态；
  - 代码示例：[[Delegate.cs|委托模式]]

#### 空对象模式(Null Object)

  - 定义：当一个对象的行为取决于另一个对象的状态，并且它需要响应空值时，可以使用空对象模式。空对象模式是一种对象行为型模式
  - 优点：符合单一职责原则；符合开闭原则；符合迪米特法则
  - 缺点：可能带来性能问题；可能存在内存泄漏
  - 适用场景：需要对一个对象的行为进行封装，以便在不同的场景中使用不同的行为；需要对一个对象的行为进行动态的添加、删除和修改；一个对象的行为取决于另一个对象的状态；
  - 代码示例：[[NullObject.cs|空对象模式]]

### 其他模式

#### MVC模式

  - 定义：MVC模式是一种软件设计模式，它把一个应用程序分为三个基本部分：模型(Model)、视图(View)和控制器(Controller)
  - 优点：分离了表示层和数据逻辑层；提高了代码的可重用性；提高了代码的可测试性；提高了代码的可维护性
  - 缺点：增加了系统的复杂性；增加了系统的实现难度
  - 适用场景：当一个系统需要分层设计时；当一个系统需要面向对象设计时；当一个系统需要灵活的可扩展性时

#### MVVM模式

  - 定义：MVVM模式是一种软件设计模式，它把一个应用程序分为三个基本部分：模型(Model)、视图(View)和视图模型(ViewModel)
  - 优点：分离了表示层和数据逻辑层；提高了代码的可重用性；提高了代码的可测试性；提高了代码的可维护性
  - 缺点：增加了系统的复杂性；增加了系统的实现难度
  - 适用场景：当一个系统需要分层设计时；当一个系统需要面向对象设计时；当一个系统需要灵活的可扩展性时

#### MVP模式

  - 定义：MVP模式是一种软件设计模式，它把一个应用程序分为三个基本部分：模型(Model)、视图(View)和视图模型(Presenter)
  - 优点：分离了表示层和数据逻辑层；提高了代码的可重用性；提高了代码的可测试性；提高了代码的可维护性
  - 缺点：增加了系统的复杂性；增加了系统的实现难度
  - 适用场景：当一个系统需要分层设计时；当一个系统需要面向对象设计时；当一个系统需要灵活的可扩展性时

#### MVA模式

  - 定义：MVA模式是一种软件设计模式，它把一个应用程序分为三个基本部分：模型(Model)、视图(View)和应用(Application)
  - 优点：分离了表示层和数据逻辑层；提高了代码的可重用性；提高了代码的可测试性；提高了代码的可维护性
  - 缺点：增加了系统的复杂性；增加了系统的实现难度
  - 适用场景：当一个系统需要分层设计时；当一个系统需要面向对象设计时；当一个系统需要灵活的可扩展性时

#### MVW模式

  - 定义：MVW模式是一种软件设计模式，它把一个应用程序分为三个基本部分：模型(Model)、视图(View)和视图模型(Widget)
  - 优点：分离了表示层和数据逻辑层；提高了代码的可重用性；提高了代码的可测试性；提高了代码的可维护性
  - 缺点：增加了系统的复杂性；增加了系统的实现难度
  - 适用场景：当一个系统需要分层设计时；当一个系统需要面向对象设计时；当一个系统需要灵活的可扩展性时
