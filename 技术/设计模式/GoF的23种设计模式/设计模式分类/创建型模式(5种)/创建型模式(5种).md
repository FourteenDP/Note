---
title: 创建型模式(5种)
aliases: [创建型模式(5种)]
tags: []
date created: 2023-03-07 12:47:59
date updated: 2023-03-07 13:53:57
---

# 创建型模式(5种)

- 创建型模式是对类的实例化过程进行抽象，能够将软件模块中对象的创建和对象的使用分离
- 创建型模式的主要特点是“将对象的创建与使用分离”
- 创建型模式的主要优点是降低系统的耦合度，一个类的实例化可以延迟到其使用时
- 创建型模式的主要缺点是需要额外的工作，有时候会增加系统的复杂度
- 创建型模式的主要应用场景是：系统要独立于它的产品的创建、构成和表示时；一个类要通过其子类来指定创建哪个对象时；一个类要通过其子类来指定创建哪个对象时；一个类的实例对象只能有几个不同状态组合中的一种时；系统要求提供一个类的库，所有的类都要符合一定的接口时；系统要求提供一个类的库，所有的类都要符合一定的接口时
- 创建型模式包括：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

## 工厂方法模式(Factory Method)

- 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
- 解释：工厂方法模式是一种类创建型模式，它提供了一个抽象工厂接口，让其子类决定实例化哪一个工厂类，从而实现创建不同产品的功能
- 优点：用户只需要关心所需产品对应的工厂，无须关心创建细节，加入新产品符合开闭原则，提高了系统的可扩展性
- 缺点：类的个数容易过多，增加复杂度；增加了系统的抽象性和理解难度
- 适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节；一个类通过其子类来指定创建哪个对象
- 模式结构：
  - 产品角色：抽象产品类，定义了产品的规范，描述了产品的主要特性和功能
  - 具体产品角色：具体产品类，实现抽象产品角色所定义的接口，某具体产品有专门的具体工厂创建，它们之间往往一一对应
  - 创建者角色：抽象工厂类，定义了工厂方法，用于创建产品，声明了工厂方法(Factory Method)，该方法返回一个产品，Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象，它也可以调用工厂方法以创建一个Product对象
  - 具体创建者角色：具体工厂类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个ConcreteProduct类型的实例

## 抽象工厂模式(Abstract Factory)

- 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
- 解释：抽象工厂模式是一种类创建型模式，它提供了一个创建产品族的接口，其每个子类可以生产一系列相关的产品
- 优点：隔离了具体类的生成，使得客户端不需要知道什么被创建；将一个系列的产品族统一到一起创建；增加新的产品族很方便，无须修改已有系统，符合开闭原则
- 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
- 适用场景：系统中有多于一个的产品族，而系统只消费其中某一产品族；系统要求提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现
- 模式结构：
  - 抽象工厂（Abstract Factory）：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口
  - 具体工厂（Concrete Factory）：这个角色含有与业务密切相关的逻辑，并且受到抽象工厂角色的约束。在具体工厂中提供了工厂方法，用于返回一个产品。它可以是具体的，也可以是抽象的，也可以是另一个工厂的实例
  - 抽象产品（Product）：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口
  - 具体产品（Concrete Product）：这个角色实现了抽象产品角色所定义的接口
  - 客户端（Client）：客户端无须知道产品的具体类，只需要知道具体工厂的类名即可

## [[单例模式(Singleton)]]

## 建造者模式(Builder)

- 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
- 解释：建造者模式是一种对象创建型模式，其目的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
- 优点：封装性好，构建和表示分离；扩展性好，各个具体的建造者相互独立，有利于系统的解耦；客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险
- 缺点：产生多余的Builder对象以及Director对象；产品内部发生变化，建造者都要修改，成本较大
- 适用场景：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品
- 模式结构：
  - 产品角色（Product）：一个具体的产品对象
  - 抽象建造者（Builder）：创建一个Product对象的各个部件指定的抽象接口
  - 具体建造者（Concrete Builder）：实现接口，构建和装配各个部件
  - 指挥者（Director）：构建一个使用Builder接口的对象
  - 客户（Client）：使用Director类来构建和使用产品对象

## 原型模式(Prototype)

- 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
- 解释：原型模式是一种对象创建型模式，其用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
- 优点：性能提高；逃避构造函数的约束
- 缺点：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有类进行改造时，需要修改代码，违背了开闭原则；当实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦；深克隆、浅克隆要运用得当
- 适用场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；一个对象多个修改者的场景，例如，一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝
- 模式结构：
  - 抽象原型类（Prototype）：规定了具体原型对象必须实现的接口
  - 具体原型类（Concrete Prototype）：实现抽象原型类的clone()方法，它是可被复制的对象
  - 访问类（Client）：访问原型接口来复制原型对象
  - 注：原型模式的核心是克隆，而克隆分为浅克隆和深克隆，浅克隆只是将对象的属性值复制一份，而引用类型的属性值仍然指向原来的对象，深克隆将对象的属性值和引用类型的属性值都复制一份
