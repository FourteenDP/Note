---
title: 结构型模式(7种)
aliases: [结构型模式(7种)]
tags: 
date created: 2023-03-07 12:47:59
date updated: 2023-03-07 13:48:49
---

# 结构型模式(7种)

- 结构型模式是对类或对象如何组合成较大的结构进行描述，能够使结构更加灵活，更加易于使用
- 结构型模式的主要特点是“关注类或对象的组合”
- 结构型模式的主要优点是可以提高类的透明性和复用性，可以提高系统的整体性能
- 结构型模式的主要缺点是使用结构型模式需要产生很多额外的类，增加系统的复杂度
- 结构型模式的主要应用场景是：需要增加由于继承而产生的复杂性时；需要对客户隐藏一个类的具体实现时；需要提高类的复用性时；需要对类进行分层次进行设计时
- 结构型模式包括：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式

## 适配器模式(Adapter)

- 定义：将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
- 解释：适配器模式是一种结构型设计模式，它能将对象的接口转换成不同的接口，让原本接口不兼容的对象可以一起工作
- 优点：可以让任何两个没有关联的类一起运行；提高了类的复用；增加了类的透明度；灵活性好
- 缺点：过多使用适配器，会让系统非常零乱，不易整体进行把握；由于JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类
- 适用场景：系统需要使用现有的类，而此类的接口不符合系统的需要；想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；（对象适配器）需要适配的是一个类，但是适配者类不是抽象类，而是一个具体类，而且不可能改变它的代码
- 模式结构：
  - 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口
  - 适配者（Adaptee）类：需要适配的类
  - 适配器（Adapter）类：通过包装一个适配者对象，把原接口转换成目标接口
  - 客户（Client）类：客户端通过适配器发起请求

## 桥接模式(Bridge)

- 定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化
- 解释：桥接模式是一种结构型设计模式，它能将抽象部分与它的实现部分分离，使它们都可以独立地变化
- 优点：分离抽象接口及其实现部分；提高了系统的可扩充性；符合开闭原则；符合合成复用原则
- 缺点：桥接模式的引入会增加系统的理解与设计难度；由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程
- 适用场景：不希望或不适用使用继承的场景；接口或抽象类不稳定的场景；重用性要求较高的场景
- 模式结构：
  - 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用
  - 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类的抽象方法
  - 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用
  - 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现
  - 客户（Client）类：通过抽象化角色与实现化角色之间的组合关系，使用抽象化角色定义的接口

## 装饰模式(Decorator)

- 定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活
- 解释：装饰模式是一种结构型设计模式，它能动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活
- 优点：装饰类和被装饰类可以独立发展，而不会相互耦合；可以动态扩展一个实现类的功能；符合开闭原则
- 缺点：多层装饰比较复杂；会出现更多的代码，更多的类，增加程序的复杂性
- 适用场景：扩展一个类的功能或给一个类增加附加职责；动态的给一个对象增加功能，这些功能可以再动态的撤销；增加加密功能的场景
- 模式结构：
  - 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象
  - 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责
  - 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口
  - 具体装饰（Concrete Decorator）角色：负责给构件对象“贴上”附加的责任
  - 客户（Client）类：通过装饰角色为构件动态地添加职责

## 组合模式(Composite)

- 定义：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性
- 解释：组合模式是一种结构型设计模式，它允许你将对象组合成树形结构，并且能像使用独立对象一样使用它们
- 优点：高层模块调用简单；节点自由增加；容易增加新的容器构件和叶子构件
- 缺点：规定了所有的容器构件都必须有子节点，这样会限制容器构件的复用性
- 适用场景：希望客户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象；需要表示对象的部分-整体层次结构；希望客户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象
- 模式结构：
  - 抽象构件（Component）角色：为参加组合的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为。声明一个接口用于访问和管理Component的子组件
  - 树叶构件（Leaf）角色：在组合中表示叶子节点对象，叶子节点没有子节点
  - 树枝构件（Composite）角色：定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，如增加(add)和删除(remove)等
  - 客户（Client）类：通过Component接口操纵组合部件的对象

## 外观(门面)模式(Facade)

- 定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
- 解释：外观模式是一种结构型设计模式，它为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
- 优点：减少系统相互依赖；提高灵活性；提高了安全性
- 缺点：不符合开闭原则；增加子系统，扩展子系统行为容易引入风险
- 适用场景：为复杂的模块或子系统提供外界访问的模块；子系统相对独立；预防低水平人员带来的风险
- 模式结构：
  - 外观（Facade）角色：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去
  - 子系统（Sub System）角色：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如A1，A2，A3）。子系统并不知道外观的存在，对于子系统而言，外观仅仅是另外一个客户端而已
  - 客户（Client）角色：在正常情况下，本角色已经被系统的外观角色取代。本角色仅仅是一个为了提供给外界访问子系统的接口

## 享元模式(Flyweight)

- 定义：运用共享技术有效地支持大量细粒度的对象
- 解释：享元模式是一种结构型设计模式，运用共享技术有效地支持大量细粒度的对象
- 优点：大大减少对象的创建，降低系统的内存，使效率提高
- 缺点：提高了系统的复杂性；为了节省内存，共享了内部状态，分离出了外部状态，而读取外部状态使得运行时间变长
- 适用场景：系统中有大量对象；这些对象消耗大量内存；这些对象的状态大部分可以外部化；这些对象可以按照内部状态分成较少的大类；系统不依赖于这些对象身份，这些对象是不可分辨的
- 模式结构：
  - 抽象享元（Flyweight）角色：是所有的具体享元类的超类，为这些类规定出需要实现的公共接口
  - 具体享元（Concrete Flyweight）角色：实现抽象享元角色所规定的接口
  - 享元工厂（Flyweight Factory）角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象
  - 外部状态（Unshared Concrete Flyweight）角色：指那些不需要共享的外部状态。由于享元对象可以被共享，而外部状态不能被共享，所以必须将其存储外部。当调用一个享元对象的操作时，传入一个外部状态
  - 内部状态（Shared Concrete Flyweight）角色：指那些可以共享的内部状态。内部状态可以被一些对象共享。内部状态存储于享元对象内部并且不会随环境的改变而改变
  - 客户（Client）角色：本角色需要维护一个对所有享元对象的引用。当一个客户端对象调用一个享元对象的时候，必须传入一个外部状态

## 代理模式(Proxy)

- 定义：为其他对象提供一种代理以控制对这个对象的访问
- 解释：代理模式是一种结构型设计模式，为其他对象提供一种代理以控制对这个对象的访问
- 优点：职责清晰；高扩展性；智能化
- 缺点：增加了系统的复杂度；在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；增加了系统的开销
- 适用场景：保护目标对象；增强目标对象；控制对目标对象的访问
- 模式结构：
  - 抽象主题（Subject）角色：声明了真实主题和代理主题的共同接口，这样一来在任何可以使用真实主题的地方都可以使用代理主题
  - 代理主题（Proxy）角色：代理主题角色内部含有对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作
  - 真实主题（Real Subject）角色：定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作
  - 客户（Client）角色：通过一个代理主题角色间接调用真实主题角色中定义的操作
