---
title: 非GoF设计模式
aliases: [非GoF设计模式, 其它设计模式, 其它模式]
tags: [计算机基础, 设计模式]
date created: 2023-03-02 01:01:25
date updated: 2023-03-02 01:17:42
---

# 非GoF设计模式

- 对软件开发中一些特殊情况的解决方案,它们并不属于GoF23种设计模式,但是也是非常重要的,也是我们在软件开发中经常使用的

## [[事件总线(Event Bus)]] 别称发布/订阅模式(Publish/Subscribe)

## 空对象模式(Null Object)

- 定义：在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为
- 解释：在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方
- 优点：它可以在空对象模式中将空对象的检查逻辑化为多态的方法调用，而不是依赖于条件语句
- 缺点：它可能会造成一些性能问题，因为它需要创建额外的对象
- 适用场景：需要在不检查空值的情况下对数据进行操作；需要在不同的情况下执行不同的操作，而且操作可以在运行时动态地进行；需要在不同的情况下执行不同的操作，而且操作可以在运行时动态地进行
- 模式结构：
  - 抽象类（AbstractObject）：抽象类定义了一个接口，以规范准备接收所有请求的对象。这个接口包含了一个方法，该方法接收一个请求，并且返回一个响应。这个接口也可以包含其他方法，用于设置和获取对象的属性。
  - 具体类（RealObject）：具体类实现了在抽象类中定义的接口。具体类通常会在接收到请求后，执行一些核心业务逻辑，并且在返回结果之前，执行一些必要的处理，比如数据校验等。
  - 空对象（NullObject）：空对象是一个符合抽象类接口的实现类，但是在实现类中不包含任何业务逻辑，通常会在空对象中将所有的方法实现为空（比如返回 null 或者抛出异常等）。
  - 客户端（Client）：客户端是通过抽象类来调用实现类的，而不是通过具体类来调用实现类的。客户端可以在运行时，通过设置不同的具体类来获得不同的行为

## 链模式(Chain Of Responsibility)

- 定义：在职责链模式（Chain of Responsibility Pattern）中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。职责链模式是一种对象行为型模式
- 解释：在职责链模式中，我们创建一个抽象类，它的子类可以形成一条链，请求在这个链上传递，直到链上的某一个对象决定处理此请求
- 优点：职责链模式的优点在于它能够根据请求的内容将请求的发送者和接收者解耦，使得一个对象无需知道链的结构即可发送请求，同时也无需知道链上的请求处理者是谁以及它是如何处理的，请求只需要传递到链上即可，而链上的处理者会自行处理
- 缺点：职责链模式的缺点在于它不能保证请求一定被链上的处理者处理，因为一个请求并没有明确的接收者，所以它有可能一直传递到链的末端都得不到处理
- 应用场景：职责链模式通常适用于以下场景：一个请求的处理需要多个对象当中的一个或几个协作处理，具体哪个对象处理该请求由运行时刻自动确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求
- 模式结构：
  - 抽象处理者（Handler）：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
  - 具体处理者（ConcreteHandler）：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。一个具体处理者对象只能在两个行为中选择一种：自己处理（承担责任）或者把责任推给下家。
  - 客户类（Client）：客户类将请求发送给具体处理者对象

## 委托模式(Delegate)

- 定义：委托模式（Delegation Pattern）又叫代理模式，是一种对象行为型模式，委托模式的核心是将一个类的实现委托给另一个类来完成
- 解释：委托模式的核心是将一个类的实现委托给另一个类来完成，委托模式的好处在于可以将实现细节隐藏，从而减少类的复杂度，同时也降低了系统的耦合度
- 优点：委托模式的优点在于它能够将实现细节隐藏，从而减少类的复杂度，同时也降低了系统的耦合度
- 缺点：委托模式的缺点在于它会导致系统设计中类的数量增加
- 应用场景：委托模式通常适用于以下场景：需要为某个类提供多种实现方式，或者需要动态地为某个类的对象提供不同的实现方式；需要为某个类的对象提供不同的实现方式，但是又不希望暴露太多的实现细节
- 模式结构：
  - 抽象委托者（Delegate）：定义一个委托方法，用于调用具体委托者的方法
  - 具体委托者（ConcreteDelegate）：实现抽象委托者的委托方法，负责具体的业务逻辑
  - 委托者（Client）：通过抽象委托者调用具体委托者的委托方法

## 数据访问模式(Data Access Object)

- 定义：数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。
- 解释：数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。
- 优点：数据访问对象模式的优点在于它提供了一种统一的数据访问方式，从而使得数据访问层的代码可以被重用，从而降低了系统的维护成本
- 缺点：数据访问对象模式的缺点在于它可能会导致系统设计中类的数量增加
- 应用场景：数据访问对象模式通常适用于以下场景：当系统需要提供一个应用程序与多个数据库的数据源交互时，可以使用数据访问对象模式；当系统需要提供一个应用程序与多个数据库的数据源交互时，可以使用数据访问对象模式
- 模式结构：
  - 数据访问对象接口（Data Access Object Interface）：定义了在一个模型对象上要执行的标准操作
  - 数据访问对象实体类（Data Access Object concrete class）：实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制
  - 模型对象/数值对象（Model Object/Value Object）：该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据

## 惰性模式(Lazy Initialization)

- 定义：惰性模式（Lazy Initialization Pattern）是一种常用的优化模式，它的定义是：当一个对象被创建时，不创建它的所有依赖对象，而是在需要的时候再创建它的依赖对象。以下是惰性模式的参与者。
- 解释：惰性模式（Lazy Initialization Pattern）是一种常用的优化模式，它的定义是：当一个对象被创建时，不创建它的所有依赖对象，而是在需要的时候再创建它的依赖对象。以下是惰性模式的参与者。
- 优点：惰性模式的优点在于它可以减少内存的使用量，因为它在需要的时候才创建对象
- 缺点：惰性模式的缺点在于它可能会导致系统设计中类的数量增加
- 应用场景：惰性模式通常适用于以下场景：当一个对象的创建需要很多资源时，可以使用惰性模式；当一个对象的创建需要很多资源时，可以使用惰性模式
- 模式结构：
  - 惰性加载类（Lazy Load Class）：该类包含了一个实例化对象的引用，当需要使用该对象时，可以通过调用该类的方法来获取该对象
  - 实例化对象（Instantiated Object）：该对象是惰性加载类的依赖对象，当惰性加载类需要使用该对象时，才对该对象进行实例化
  - 客户端（Client）：客户端是惰性模式的调用者，它通过调用惰性加载类的方法来使用实例化对象

## 等待者模式(Waiter Pattern)

- 定义：等待者模式（Waiter Pattern）是一种常用的优化模式，它的定义是：当一个对象的创建需要很多资源时，可以使用等待者模式
- 解释：等待者模式（Waiter Pattern）是一种常用的优化模式，它的定义是：当一个对象的创建需要很多资源时，可以使用等待者模式
- 优点：等待者模式的优点在于它可以减少系统的启动时间
- 缺点：等待者模式的缺点在于它可能会导致系统设计中类的数量增加
- 应用场景：等待者模式通常适用于以下场景：当一个对象的创建需要很多资源时，可以使用等待者模式
- 模式结构：
  - 等待者（Waiter）：该类包含了一个实例化对象的引用，当需要使用该对象时，可以通过调用该类的方法来获取该对象
  - 实例化对象（Instantiated Object）：该对象是等待者的依赖对象，当等待者需要使用该对象时，才对该对象进行实例化
  - 客户端（Client）：客户端是等待者模式的调用者，它通过调用等待者的方法来使用实例化对象

## 防抖与节流模式(Debounce & Throttle)

- 防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
- 节流：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效
- 适用场景：搜索框搜索联想、窗口大小 resize、按钮提交表单、滚动加载更多等

## [[柯里化(Currying)与偏函数(Partial Function)模式]]
