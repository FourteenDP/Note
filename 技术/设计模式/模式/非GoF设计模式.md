---
title: 非GoF设计模式
aliases: [非GoF设计模式, 其它设计模式, 其它模式]
tags: [计算机基础, 设计模式]
date created: 2023-03-02 01:01:25
date updated: 2023-03-02 01:17:42
---

# 非GoF设计模式

- 对软件开发中一些特殊情况的解决方案,它们并不属于GoF23种设计模式,但是也是非常重要的,也是我们在软件开发中经常使用的

## 发布订阅模式(Publish/Subscribe)

- 定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新
- 解释：发布订阅模式是一种消息模型，消息的发送者（发布者）不会将消息直接发送给特定的接收者（订阅者），而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣类别的消息，无需了解哪些发布者（如果有的话）存在。发布者和订阅者之间没有直接联系，彼此完全独立。发布者和订阅者之间的通信是通过一个第三方组件（代理）来完成的，这个组件承担了消息的路由、过滤、分发、接收等功能。发布订阅模式是一种松耦合的消息模型，发布者和订阅者之间的关系是动态的，发布者和订阅者可以在任何时候自由地建立和解除关系，而不影响彼此之间的业务逻辑。发布订阅模式是一种异步的消息模型，发布者在发布消息后，不会等待订阅者的响应，而是继续自己的业务逻辑，当有订阅者响应时，发布者会通过回调函数来处理订阅者的响应。发布订阅模式是一种广播的消息模型，发布者发布的消息会被所有订阅者接收到，而不是一对一的消息模型。
- 优点：符合开闭原则；符合单一职责原则；符合迪米特原则；符合依赖倒置原则
- 缺点：可能会引起性能问题;可能会引起内存泄漏
- 适用场景：一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变；一个对象必须通知其它对象，而它又不能假定其它对象是谁；需要在系统中创建一个触发链
- 模式结构：
  - 抽象主题（Subject）：抽象主题角色把所有观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
  - 具体主题（ConcreteSubject）：具体主题角色将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。
  - 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。
  - 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色通常保存一个指向具体主题对象的引用。具体观察者角色可以有任意多个。

## 空对象模式(Null Object)

- 定义：在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为
- 解释：在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方
- 优点：它可以在空对象模式中将空对象的检查逻辑化为多态的方法调用，而不是依赖于条件语句
- 缺点：它可能会造成一些性能问题，因为它需要创建额外的对象
- 适用场景：需要在不检查空值的情况下对数据进行操作；需要在不同的情况下执行不同的操作，而且操作可以在运行时动态地进行；需要在不同的情况下执行不同的操作，而且操作可以在运行时动态地进行
- 模式结构：
  - 抽象类（AbstractObject）：抽象类定义了一个接口，以规范准备接收所有请求的对象。这个接口包含了一个方法，该方法接收一个请求，并且返回一个响应。这个接口也可以包含其他方法，用于设置和获取对象的属性。
  - 具体类（RealObject）：具体类实现了在抽象类中定义的接口。具体类通常会在接收到请求后，执行一些核心业务逻辑，并且在返回结果之前，执行一些必要的处理，比如数据校验等。
  - 空对象（NullObject）：空对象是一个符合抽象类接口的实现类，但是在实现类中不包含任何业务逻辑，通常会在空对象中将所有的方法实现为空（比如返回 null 或者抛出异常等）。
  - 客户端（Client）：客户端是通过抽象类来调用实现类的，而不是通过具体类来调用实现类的。客户端可以在运行时，通过设置不同的具体类来获得不同的行为

## 链模式(Chain Of Responsibility)

- 定义：在职责链模式（Chain of Responsibility Pattern）中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。职责链模式是一种对象行为型模式
- 解释：在职责链模式中，我们创建一个抽象类，它的子类可以形成一条链，请求在这个链上传递，直到链上的某一个对象决定处理此请求
- 优点：职责链模式的优点在于它能够根据请求的内容将请求的发送者和接收者解耦，使得一个对象无需知道链的结构即可发送请求，同时也无需知道链上的请求处理者是谁以及它是如何处理的，请求只需要传递到链上即可，而链上的处理者会自行处理
- 缺点：职责链模式的缺点在于它不能保证请求一定被链上的处理者处理，因为一个请求并没有明确的接收者，所以它有可能一直传递到链的末端都得不到处理
- 应用场景：职责链模式通常适用于以下场景：一个请求的处理需要多个对象当中的一个或几个协作处理，具体哪个对象处理该请求由运行时刻自动确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求
- 模式结构：
  - 抽象处理者（Handler）：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
  - 具体处理者（ConcreteHandler）：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。一个具体处理者对象只能在两个行为中选择一种：自己处理（承担责任）或者把责任推给下家。
  - 客户类（Client）：客户类将请求发送给具体处理者对象

## 委托模式(Delegate)

- 定义：委托模式（Delegation Pattern）又叫代理模式，是一种对象行为型模式，委托模式的核心是将一个类的实现委托给另一个类来完成
- 解释：委托模式的核心是将一个类的实现委托给另一个类来完成，委托模式的好处在于可以将实现细节隐藏，从而减少类的复杂度，同时也降低了系统的耦合度
- 优点：委托模式的优点在于它能够将实现细节隐藏，从而减少类的复杂度，同时也降低了系统的耦合度
- 缺点：委托模式的缺点在于它会导致系统设计中类的数量增加
- 应用场景：委托模式通常适用于以下场景：需要为某个类提供多种实现方式，或者需要动态地为某个类的对象提供不同的实现方式；需要为某个类的对象提供不同的实现方式，但是又不希望暴露太多的实现细节
- 模式结构：
  - 抽象委托者（Delegate）：定义一个委托方法，用于调用具体委托者的方法
  - 具体委托者（ConcreteDelegate）：实现抽象委托者的委托方法，负责具体的业务逻辑
  - 委托者（Client）：通过抽象委托者调用具体委托者的委托方法

## 数据访问模式(Data Access Object)

- 定义：数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。
- 解释：数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。
- 优点：数据访问对象模式的优点在于它提供了一种统一的数据访问方式，从而使得数据访问层的代码可以被重用，从而降低了系统的维护成本
- 缺点：数据访问对象模式的缺点在于它可能会导致系统设计中类的数量增加
- 应用场景：数据访问对象模式通常适用于以下场景：当系统需要提供一个应用程序与多个数据库的数据源交互时，可以使用数据访问对象模式；当系统需要提供一个应用程序与多个数据库的数据源交互时，可以使用数据访问对象模式
- 模式结构：
  - 数据访问对象接口（Data Access Object Interface）：定义了在一个模型对象上要执行的标准操作
  - 数据访问对象实体类（Data Access Object concrete class）：实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制
  - 模型对象/数值对象（Model Object/Value Object）：该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据

## 惰性模式(Lazy Initialization)

- 定义：惰性模式（Lazy Initialization Pattern）是一种常用的优化模式，它的定义是：当一个对象被创建时，不创建它的所有依赖对象，而是在需要的时候再创建它的依赖对象。以下是惰性模式的参与者。
- 解释：惰性模式（Lazy Initialization Pattern）是一种常用的优化模式，它的定义是：当一个对象被创建时，不创建它的所有依赖对象，而是在需要的时候再创建它的依赖对象。以下是惰性模式的参与者。
- 优点：惰性模式的优点在于它可以减少内存的使用量，因为它在需要的时候才创建对象
- 缺点：惰性模式的缺点在于它可能会导致系统设计中类的数量增加
- 应用场景：惰性模式通常适用于以下场景：当一个对象的创建需要很多资源时，可以使用惰性模式；当一个对象的创建需要很多资源时，可以使用惰性模式
- 模式结构：
  - 惰性加载类（Lazy Load Class）：该类包含了一个实例化对象的引用，当需要使用该对象时，可以通过调用该类的方法来获取该对象
  - 实例化对象（Instantiated Object）：该对象是惰性加载类的依赖对象，当惰性加载类需要使用该对象时，才对该对象进行实例化
  - 客户端（Client）：客户端是惰性模式的调用者，它通过调用惰性加载类的方法来使用实例化对象

## 等待者模式(Waiter Pattern)

- 定义：等待者模式（Waiter Pattern）是一种常用的优化模式，它的定义是：当一个对象的创建需要很多资源时，可以使用等待者模式
- 解释：等待者模式（Waiter Pattern）是一种常用的优化模式，它的定义是：当一个对象的创建需要很多资源时，可以使用等待者模式
- 优点：等待者模式的优点在于它可以减少系统的启动时间
- 缺点：等待者模式的缺点在于它可能会导致系统设计中类的数量增加
- 应用场景：等待者模式通常适用于以下场景：当一个对象的创建需要很多资源时，可以使用等待者模式
- 模式结构：
  - 等待者（Waiter）：该类包含了一个实例化对象的引用，当需要使用该对象时，可以通过调用该类的方法来获取该对象
  - 实例化对象（Instantiated Object）：该对象是等待者的依赖对象，当等待者需要使用该对象时，才对该对象进行实例化
  - 客户端（Client）：客户端是等待者模式的调用者，它通过调用等待者的方法来使用实例化对象

## 防抖与节流模式(Debounce & Throttle)

- 防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
- 节流：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效
- 适用场景：搜索框搜索联想、窗口大小 resize、按钮提交表单、滚动加载更多等

## [[柯里化(Currying)]]与[[偏函数(Partial Function)]]模式
