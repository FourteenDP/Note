---
title: GoF的23种设计模式
aliases: [GoF的23种设计模式]
tags: []
date created: 2023-03-02 01:01:25
date updated: 2023-03-02 14:56:37
---

# GoF的23种设计模式

- GoF的23种设计模式是由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在1994年发表的一本名为《设计模式：可复用面向对象软件的基础》的书中提出的
- GoF的23种设计模式是基于面向对象的，所以在学习设计模式之前，先要学习面向对象的基本概念
- GoF的23种设计模式是基于SOLID原则的，所以在学习设计模式之前，先要学习SOLID原则

## 创建型模式(5种)

- 创建型模式是对类的实例化过程进行抽象，能够将软件模块中对象的创建和对象的使用分离
- 创建型模式的主要特点是“将对象的创建与使用分离”
- 创建型模式的主要优点是降低系统的耦合度，一个类的实例化可以延迟到其使用时
- 创建型模式的主要缺点是需要额外的工作，有时候会增加系统的复杂度
- 创建型模式的主要应用场景是：系统要独立于它的产品的创建、构成和表示时；一个类要通过其子类来指定创建哪个对象时；一个类要通过其子类来指定创建哪个对象时；一个类的实例对象只能有几个不同状态组合中的一种时；系统要求提供一个类的库，所有的类都要符合一定的接口时；系统要求提供一个类的库，所有的类都要符合一定的接口时
- 创建型模式包括：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

### 工厂方法模式(Factory Method)

- 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
- 解释：工厂方法模式是一种类创建型模式，它提供了一个抽象工厂接口，让其子类决定实例化哪一个工厂类，从而实现创建不同产品的功能
- 优点：用户只需要关心所需产品对应的工厂，无须关心创建细节，加入新产品符合开闭原则，提高了系统的可扩展性
- 缺点：类的个数容易过多，增加复杂度；增加了系统的抽象性和理解难度
- 适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节；一个类通过其子类来指定创建哪个对象
- 模式结构：
  - 产品角色：抽象产品类，定义了产品的规范，描述了产品的主要特性和功能
  - 具体产品角色：具体产品类，实现抽象产品角色所定义的接口，某具体产品有专门的具体工厂创建，它们之间往往一一对应
  - 创建者角色：抽象工厂类，定义了工厂方法，用于创建产品，声明了工厂方法(Factory Method)，该方法返回一个产品，Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象，它也可以调用工厂方法以创建一个Product对象
  - 具体创建者角色：具体工厂类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个ConcreteProduct类型的实例

### 抽象工厂模式(Abstract Factory)

- 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
- 解释：抽象工厂模式是一种类创建型模式，它提供了一个创建产品族的接口，其每个子类可以生产一系列相关的产品
- 优点：隔离了具体类的生成，使得客户端不需要知道什么被创建；将一个系列的产品族统一到一起创建；增加新的产品族很方便，无须修改已有系统，符合开闭原则
- 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口
- 适用场景：系统中有多于一个的产品族，而系统只消费其中某一产品族；系统要求提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现
- 模式结构：
  - 抽象工厂（Abstract Factory）：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口
  - 具体工厂（Concrete Factory）：这个角色含有与业务密切相关的逻辑，并且受到抽象工厂角色的约束。在具体工厂中提供了工厂方法，用于返回一个产品。它可以是具体的，也可以是抽象的，也可以是另一个工厂的实例
  - 抽象产品（Product）：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口
  - 具体产品（Concrete Product）：这个角色实现了抽象产品角色所定义的接口
  - 客户端（Client）：客户端无须知道产品的具体类，只需要知道具体工厂的类名即可

### [[单例模式(Singleton)]]

### 建造者模式(Builder)

- 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
- 解释：建造者模式是一种对象创建型模式，其目的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
- 优点：封装性好，构建和表示分离；扩展性好，各个具体的建造者相互独立，有利于系统的解耦；客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险
- 缺点：产生多余的Builder对象以及Director对象；产品内部发生变化，建造者都要修改，成本较大
- 适用场景：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品
- 模式结构：
  - 产品角色（Product）：一个具体的产品对象
  - 抽象建造者（Builder）：创建一个Product对象的各个部件指定的抽象接口
  - 具体建造者（Concrete Builder）：实现接口，构建和装配各个部件
  - 指挥者（Director）：构建一个使用Builder接口的对象
  - 客户（Client）：使用Director类来构建和使用产品对象

### 原型模式(Prototype)

- 定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
- 解释：原型模式是一种对象创建型模式，其用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
- 优点：性能提高；逃避构造函数的约束
- 缺点：需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有类进行改造时，需要修改代码，违背了开闭原则；当实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦；深克隆、浅克隆要运用得当
- 适用场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；一个对象多个修改者的场景，例如，一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝
- 模式结构：
  - 抽象原型类（Prototype）：规定了具体原型对象必须实现的接口
  - 具体原型类（Concrete Prototype）：实现抽象原型类的clone()方法，它是可被复制的对象
  - 访问类（Client）：访问原型接口来复制原型对象
  - 注：原型模式的核心是克隆，而克隆分为浅克隆和深克隆，浅克隆只是将对象的属性值复制一份，而引用类型的属性值仍然指向原来的对象，深克隆将对象的属性值和引用类型的属性值都复制一份

### 结构型模式(7种)

- 结构型模式是对类或对象如何组合成较大的结构进行描述，能够使结构更加灵活，更加易于使用
- 结构型模式的主要特点是“关注类或对象的组合”
- 结构型模式的主要优点是可以提高类的透明性和复用性，可以提高系统的整体性能
- 结构型模式的主要缺点是使用结构型模式需要产生很多额外的类，增加系统的复杂度
- 结构型模式的主要应用场景是：需要增加由于继承而产生的复杂性时；需要对客户隐藏一个类的具体实现时；需要提高类的复用性时；需要对类进行分层次进行设计时
- 结构型模式包括：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式

#### 适配器模式(Adapter)

- 定义：将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
- 解释：适配器模式是一种结构型设计模式，它能将对象的接口转换成不同的接口，让原本接口不兼容的对象可以一起工作
- 优点：可以让任何两个没有关联的类一起运行；提高了类的复用；增加了类的透明度；灵活性好
- 缺点：过多使用适配器，会让系统非常零乱，不易整体进行把握；由于JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类
- 适用场景：系统需要使用现有的类，而此类的接口不符合系统的需要；想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；（对象适配器）需要适配的是一个类，但是适配者类不是抽象类，而是一个具体类，而且不可能改变它的代码
- 模式结构：
  - 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口
  - 适配者（Adaptee）类：需要适配的类
  - 适配器（Adapter）类：通过包装一个适配者对象，把原接口转换成目标接口
  - 客户（Client）类：客户端通过适配器发起请求

#### 桥接模式(Bridge)

- 定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化
- 解释：桥接模式是一种结构型设计模式，它能将抽象部分与它的实现部分分离，使它们都可以独立地变化
- 优点：分离抽象接口及其实现部分；提高了系统的可扩充性；符合开闭原则；符合合成复用原则
- 缺点：桥接模式的引入会增加系统的理解与设计难度；由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程
- 适用场景：不希望或不适用使用继承的场景；接口或抽象类不稳定的场景；重用性要求较高的场景
- 模式结构：
  - 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用
  - 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类的抽象方法
  - 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用
  - 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现
  - 客户（Client）类：通过抽象化角色与实现化角色之间的组合关系，使用抽象化角色定义的接口

#### 装饰模式(Decorator)

- 定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活
- 解释：装饰模式是一种结构型设计模式，它能动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活
- 优点：装饰类和被装饰类可以独立发展，而不会相互耦合；可以动态扩展一个实现类的功能；符合开闭原则
- 缺点：多层装饰比较复杂；会出现更多的代码，更多的类，增加程序的复杂性
- 适用场景：扩展一个类的功能或给一个类增加附加职责；动态的给一个对象增加功能，这些功能可以再动态的撤销；增加加密功能的场景
- 模式结构：
  - 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象
  - 具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责
  - 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口
  - 具体装饰（Concrete Decorator）角色：负责给构件对象“贴上”附加的责任
  - 客户（Client）类：通过装饰角色为构件动态地添加职责

#### 组合模式(Composite)

- 定义：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性
- 解释：组合模式是一种结构型设计模式，它允许你将对象组合成树形结构，并且能像使用独立对象一样使用它们
- 优点：高层模块调用简单；节点自由增加；容易增加新的容器构件和叶子构件
- 缺点：规定了所有的容器构件都必须有子节点，这样会限制容器构件的复用性
- 适用场景：希望客户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象；需要表示对象的部分-整体层次结构；希望客户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象
- 模式结构：
  - 抽象构件（Component）角色：为参加组合的对象声明接口，在适当的情况下，实现所有类共有接口的缺省行为。声明一个接口用于访问和管理Component的子组件
  - 树叶构件（Leaf）角色：在组合中表示叶子节点对象，叶子节点没有子节点
  - 树枝构件（Composite）角色：定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，如增加(add)和删除(remove)等
  - 客户（Client）类：通过Component接口操纵组合部件的对象

#### 外观(门面)模式(Facade)

- 定义：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
- 解释：外观模式是一种结构型设计模式，它为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
- 优点：减少系统相互依赖；提高灵活性；提高了安全性
- 缺点：不符合开闭原则；增加子系统，扩展子系统行为容易引入风险
- 适用场景：为复杂的模块或子系统提供外界访问的模块；子系统相对独立；预防低水平人员带来的风险
- 模式结构：
  - 外观（Facade）角色：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去
  - 子系统（Sub System）角色：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如A1，A2，A3）。子系统并不知道外观的存在，对于子系统而言，外观仅仅是另外一个客户端而已
  - 客户（Client）角色：在正常情况下，本角色已经被系统的外观角色取代。本角色仅仅是一个为了提供给外界访问子系统的接口

#### 享元模式(Flyweight)

- 定义：运用共享技术有效地支持大量细粒度的对象
- 解释：享元模式是一种结构型设计模式，运用共享技术有效地支持大量细粒度的对象
- 优点：大大减少对象的创建，降低系统的内存，使效率提高
- 缺点：提高了系统的复杂性；为了节省内存，共享了内部状态，分离出了外部状态，而读取外部状态使得运行时间变长
- 适用场景：系统中有大量对象；这些对象消耗大量内存；这些对象的状态大部分可以外部化；这些对象可以按照内部状态分成较少的大类；系统不依赖于这些对象身份，这些对象是不可分辨的
- 模式结构：
  - 抽象享元（Flyweight）角色：是所有的具体享元类的超类，为这些类规定出需要实现的公共接口
  - 具体享元（Concrete Flyweight）角色：实现抽象享元角色所规定的接口
  - 享元工厂（Flyweight Factory）角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象
  - 外部状态（Unshared Concrete Flyweight）角色：指那些不需要共享的外部状态。由于享元对象可以被共享，而外部状态不能被共享，所以必须将其存储外部。当调用一个享元对象的操作时，传入一个外部状态
  - 内部状态（Shared Concrete Flyweight）角色：指那些可以共享的内部状态。内部状态可以被一些对象共享。内部状态存储于享元对象内部并且不会随环境的改变而改变
  - 客户（Client）角色：本角色需要维护一个对所有享元对象的引用。当一个客户端对象调用一个享元对象的时候，必须传入一个外部状态

#### 代理模式(Proxy)

- 定义：为其他对象提供一种代理以控制对这个对象的访问
- 解释：代理模式是一种结构型设计模式，为其他对象提供一种代理以控制对这个对象的访问
- 优点：职责清晰；高扩展性；智能化
- 缺点：增加了系统的复杂度；在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；增加了系统的开销
- 适用场景：保护目标对象；增强目标对象；控制对目标对象的访问
- 模式结构：
  - 抽象主题（Subject）角色：声明了真实主题和代理主题的共同接口，这样一来在任何可以使用真实主题的地方都可以使用代理主题
  - 代理主题（Proxy）角色：代理主题角色内部含有对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作
  - 真实主题（Real Subject）角色：定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作
  - 客户（Client）角色：通过一个代理主题角色间接调用真实主题角色中定义的操作

### 行为型模式(11种)

- 行为型模式是对在不同的对象之间划分责任和算法的抽象化，能够有效地分配职责和算法
- 行为型模式的主要特点是“关注对象之间的通信”
- 行为型模式的主要优点是可以减少系统中各类之间的耦合度，提高系统的灵活性，可以让系统更加易于维护和扩展
- 行为型模式的主要缺点是使用行为型模式会增加系统的复杂度
- 行为型模式的主要应用场景是：系统需要在不同的时间指定不同的行为时；多个类只有在算法或行为上稍有不同的场景时；系统需要动态地在几种算法中选择一种时；一个对象的行为依赖于它的状态，而且它必须在运行时刻根据状态改变它的行为时
- 行为型模式包括：模板方法模式、策略模式、命令模式、责任链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式、解释器模式

#### 模板方法模式(Template Method)

- 定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
- 解释：模板方法模式是一种只需使用继承就可以实现的非常简单的模式，它通过把不变的行为搬移到超类，去除了子类中的重复代码，从而提高了子类的可读性和可维护性
- 优点：封装不变部分，扩展可变部分；提取公共代码，便于维护；行为由父类控制，子类实现
- 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大
- 适用场景：有多个子类共有的方法，且逻辑相同；重要、复杂的算法，可以考虑使用模板方法模式；重构时，把相同的代码抽取到父类中，然后通过钩子函数约束其行为
- 模式结构：
  - 抽象类（Abstract Class）：实现了模板方法，定义了算法的骨架，具体子类将重写其方法
  - 具体子类（Concrete Class）：实现抽象类中的抽象方法，已完成完整的算法

#### 策略模式(Strategy)

- 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换
- 解释：策略模式是一种定义一系列算法的方法，从概念上来看，所有的这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少各种算法类与使用算法类之间的耦合
- 优点：算法可以自由切换；避免使用多重条件判断；扩展性良好
- 缺点：策略类会增多；所有策略类都需要对外暴露
- 适用场景：系统有很多类，而它们的区别仅仅在于它们的行为不同；一个系统需要动态地在几种算法中选择一种
- 模式结构：
  - 抽象策略类（Strategy）：策略类，通常由一个接口或抽象类实现
  - 具体策略类（Concrete Strategy）：包装了相关的算法和行为
  - 环境类（Context）：持有一个策略类的引用，最终给客户端调用
  - 客户端（Client）：创建具体策略类的对象，并将其传递给环境类

#### 命令模式(Command)

- 定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
- 解释：命令模式是一种数据驱动的设计模式，它属于行为型模式。命令模式将请求发送者和请求接收者解耦，请求发送者无需知道请求接收者的存在，也无需知道请求的具体实现，只需知道请求的类型即可，请求接收者也无需知道请求发送者的存在，只需实现请求接口即可
- 优点：降低系统耦合度；容易扩展新的命令和一组命令；方便实现对请求的Undo和Redo
- 缺点：可能导致某些系统有过多的具体命令类；增加系统的复杂度
- 适用场景：认为是命令的地方都可以使用命令模式；需要抽象出等待执行的行为时；需要在不同的时间指定请求、将请求排队时；需要支持命令的撤销（Undo）操作和恢复（Redo）操作时；需要将一组操作组合在一起，即支持宏命令时
- 模式结构：
  - 抽象命令类（Command）：声明了用于执行请求的execute()方法，通过这个方法可以调用请求接收者的相关操作
  - 具体命令类（Concrete Command）：是抽象命令类的子类，实现了execute()方法，它对应具体的接收者对象，将接收者对象的动作绑定其中
  - 请求者（Invoker）：要求该命令执行这个请求
  - 请求接收者（Receiver）：知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者
  - 客户端（Client）：创建一个具体命令对象并确定其接收者

#### 责任链模式(Chain Of Responsibility)

- 定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系；将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止
- 解释：责任链模式是一种对象行为型模式，其主要优点如下。降低了对象之间的耦合度，该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。增强了系统的可扩展性，可以根据需要增加新的请求处理类，满足开闭原则。增强了给对象指派职责的灵活性，当工作流程发生变化时，允许动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。简化了对象之间的连接，每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的if或者if…else语句
- 优点：降低耦合度；简化了对象；增强了给对象指派职责的灵活性；增加新的请求处理类很方便
- 缺点：不能保证请求一定被接收；系统性能将受到一定影响，而且在进行代码调试时不太方便；可能不容易观察运行时的特征，有碍于除错
- 适用场景：有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求
- 模式结构：
  - 抽象处理者（Handler）：定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个接口通常由抽象类或者接口实现
  - 具体处理者（Concrete Handler）：处理它所负责的请求，可访问它的后继者。如果可处理该请求，就处理之；否则就将该请求转发给它的后继者
  - 客户类（Client）：创建处理链，并向链头的处理者对象提交请求，它不关心处理细节和请求的传递过程

#### 状态模式(State)

- 定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来好像修改了它的类
- 解释：状态模式是一种对象行为型模式，其主要优点如下。状态模式的结构清晰，状态和环境之间的关系明确，状态模式是一种对象行为型模式，其主要优点如下。状态模式的结构清晰，状态和环境之间的关系明确，状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。通过定义新的子类很容易增加新的状态和转换。允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件分支语句。可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
- 优点：封装了转换规则；枚举可能的状态，在枚举状态之前需要确定状态种类；将所有与某个状态有关的行为都放入一个类中，只需要改变对象所属的类即可改变对象的状态，而不是修改对象的状态
- 缺点：状态模式的使用必然会增加系统类和对象的个数；状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱
- 适用场景：一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为；代码中包含大量与对象状态有关的条件语句；对象的行为依赖于它的状态，而且它必须在运行时刻根据状态改变它的行为；一个操作中含有庞大的多分支语句，且这些分支依赖于该对象的状态
- 模式结构：
  - 抽象状态（State）：定义一个接口以封装与Context的一个特定状态相关的行为
  - 具体状态（Concrete State）：每一个具体状态类都实现了抽象状态定义的接口
  - 环境类（Context）：定义客户感兴趣的接口，维护一个ConcreteState子类的实例，这个实例定义当前状态
  - 客户类（Client）：创建一个ConcreteState对象，以便让它记录当前状态

#### [[观察者模式(Observer)]]



#### 中介者模式(Mediator)

- 定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
- 解释：中介者模式是一种对象行为型模式，其主要优点如下：
  - 中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构
  - 中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，你可以独立地改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”
  - 可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展
- 优点：减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者；各同事之间的解耦；可以独立的改变和复用每一个同事和中介者；简化了对象之间的交互；中介者模式可以将网状的多对多关系转换成相对简单的一对多关系
- 缺点：中介者会庞大，变得复杂难以维护
- 适用场景：系统中对象之间存在复杂的引用关系，导致它们之间的依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类
- 模式结构：
  - 抽象中介者（Mediator）：定义统一的接口，用于各同事角色之间的通信
  - 具体中介者（Concrete Mediator）：实现抽象中介者，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令
  - 抽象同事类（Colleague）：定义各同事类公有的方法，并声明了一些抽象方法来供子类实现，同时维持一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信
  - 具体同事类（Concrete Colleague）：实现抽象同事类中的方法，它需要维持一个对具体中介者对象的引用，其对象通过该引用与中介者通信
  - 客户类（Client）：通过具体中介者类调用同事对象的业务方法

#### 备忘录模式(Memento)

- 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态
- 解释：备忘录模式是一种对象行为型模式，其主要优点如下：
  - 备忘录模式简化了客户类，客户不需要知道与备忘录类的内部细节
  - 备忘录模式将发起人对象的状态存储到了备忘录对象中，从而简化了发起人类
  - 备忘录模式实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动
  - 备忘录模式简化了原发器的设计，原发器不再需要管理备忘录的生命周期
- 优点：为用户提供一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态，实现撤销操作
- 缺点：资源消耗过大，如果需要保存的原发器类的成员变量太多，将消耗很大的内存资源
- 适用场景：保存和恢复数据相关的业务场景；后悔药功能；打游戏时的存档功能
- 模式结构：
  - 发起人（Originator）：创建一个含有当前的内部状态的备忘录对象，使用备忘录对象存储其内部状态
  - 备忘录（Memento）：负责存储发起人对象的内部状态，在需要的时候提供这些内部状态给发起人对象
  - 管理者（Caretaker）：负责保存备忘录对象，但是不能对备忘录对象的内容进行操作或检查
  - 客户类（Client）：创建一个备忘录对象，将发起人对象的内部状态存储起来；从备忘录对象中恢复发起人对象的内部状态

#### 解释器模式(Interpreter)

- 定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子
- 解释器模式是一种类行为型模式，其主要优点如下：
  - 易于改变和扩展文法：由于在解释器模式中使用类来表示文法规则，因此可以使用继承等机制来改变或扩展文法
  - 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言
  - 实现文法较为容易：在抽象语法树中的每一个表达式节点类都是相似的，所以实现其文法较为容易
- 优点：扩展性好，灵活；增加了新的解释表达式的方式；易于实现简单文法
- 缺点：可利用场景少；对于复杂的文法比较难维护；解释器模式会引起类膨胀；解释器模式采用递归调用方法
- 适用场景：可以将一个需要解释执行的语言中的句子表示为一个抽象语法树；一些重复出现的问题可以用一种简单的语言来进行表达；一个简单语法需要解释的场景
- 模式结构：
  - 抽象表达式（Expression）：声明一个所有的具体表达式角色都需要实现的抽象接口，这个接口主要是一个interpret()方法，称为解释操作
  - 终结符表达式（TerminalExpression）：实现与文法中的终结符相关联的解释操作，文法中每一个终结符都有一个具体终结表达式与之相对应，实现抽象表达式中所要求的接口，主要是一个interpret()方法，文法中的每一个终结符都有一个具体终结表达式与之相对应
  - 非终结符表达式（NonterminalExpression）：文法中的非终结符对应的解释器，为文法中的非终结符实现解释操作，文法中的每一条规则都需要一个非终结符表达式
  - 环境类（Context）：包含解释器之外的一些全局信息，一般是HashMap
  - 客户类（Client）：构建抽象语法树，解释表达式

#### 迭代器模式(Iterator)

- 定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示
- 解释：迭代器模式是一种对象行为型模式，其主要优点如下：
  - 它支持以不同的方式遍历一个聚合对象，甚至可以自定义迭代器的子类以支持新的遍历
  - 迭代器简化了聚合类，聚合类不再需要暴露它的内部表示，而且可以让客户代码更简洁
  - 在同一个聚合上可以有多个遍历，因此可以同时有多个对聚合对象的访问
  - 迭代器简化了聚合类的设计，聚合类不再需要实现createIterator()方法，而且不需要对外暴露内部表示
  - 客户端不需要关心聚合对象的内部表示，只需要关心聚合对象是否还有下一个元素，以及如何获取下一个元素即可
- 优点：分离了集合对象的遍历行为；迭代器简化了聚合类；在同一个聚合上可以有多个遍历；在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码
- 缺点：类的个数成对增加，增加了系统的复杂性；增加了系统的抽象性和理解难度
- 适用场景：访问一个聚合对象的内容而无须暴露它的内部表示；需要为聚合对象提供多种遍历方式；为遍历不同的聚合结构提供一个统一的接口
- 模式结构：
  - 抽象聚合（Aggregate）：定义存储、添加、删除聚合对象以及创建迭代器对象的接口
  - 具体聚合（ConcreteAggregate）：实现抽象聚合类，返回一个具体迭代器的实例
  - 抽象迭代器（Iterator）：定义访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：取得下一个元素、判断是否遍历结束、当前元素等
  - 具体迭代器（ConcreteIterator）：实现抽象迭代器，完成集合的迭代
  - 客户端（Client）：通过具体迭代器来遍历具体聚合

#### 访问者模式(Visitor)

- 定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作
- 解释：访问者模式是一种对象行为型模式，其主要优点如下：
  - 访问者模式使得增加新的操作变得容易，因为增加新的操作就意味着增加一个新的访问者，访问者模式将有关的行为集中到一个访问者对象中，其改变不会影响系统数据结构，符合“开闭原则”
  - 访问者模式可以实现有关操作之间的分离，从而使得每个操作集中到一个访问者对象中，而不是分散在一个个的元素类中
  - 访问者模式使得增加新的数据结构变得容易，如增加一个新的元素类，无须修改原有系统，符合“开闭原则”
- 优点：符合单一职责原则；优秀的扩展性；灵活性
- 缺点：具体元素对访问者公布细节，违反了迪米特原则；具体元素变更比较困难；违反了依赖倒置原则，依赖了具体类，没有依赖抽象
- 适用场景：对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作；需要对一个对象结构中的对象进行很多不同且不相关的操作，而需要避免让这些操作“污染”这些对象的类；对象结构中的对象需要提供多种不同的并且不相关的操作，而且需要避免让这些操作“污染”这些对象的类；需要定义对象结构的高层操作，而又不想让这些操作污染这些对象的类
- 模式结构：
  - 抽象访问者（Visitor）：为该对象结构中具体元素角色声明一个访问操作接口
  - 具体访问者（ConcreteVisitor）：实现抽象访问者所声明的接口，也就是访问者访问到一个具体元素后所作的具体操作
  - 抽象元素（Element）：定义一个接受访问操作，它以一个抽象访问者作为参数
  - 具体元素（ConcreteElement）：实现抽象元素所规定的接受访问操作
  - 对象结构（ObjectStructure）：能枚举它的元素，可以提供一个高层的接口以允许该访问者访问它的元素
  - 客户端（Client）：通过对象结构中的元素提供的高层接口来使用访问者模式
